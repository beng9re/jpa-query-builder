# jpa-query-builder



## 1단계 - Reflection

* **요구사항 1 - Car 클래스의 정보 출력**
  - [X] src/test/java/persistence/study > Car 클래스의 모든 필드, 생성자, 메소드에 대한 정보를 출력한다.

* **요구사항 2 - Car 클래스의 test로 시작하는 메소드 실행**
  - [X] Car 객체의 메소드 중 test로 시작하는 메소드를 자동으로 실행한다. 
  - [X] 같이 Car 클래스에서 test로 시작하는 메소드만 Java Reflection을 활용해 실행하도록 구현한다.
  - [X] 구현은 src/test/java/persistence/study > ReflectionTest 클래스의 testMethodRun() 메소드에 한다.

* **요구사항 3 - @PrintView 애노테이션 메소드 실행**
  - [X] @PrintView애노테이션일 설정되어 있는 메소드를 자동으로 실행한다. 
  - [X] Java Reflection을 활용해 실행하도록 구현한다.
  - [X] 구현은 src/test/java/persistence/study > ReflectionTest 클래스의 testAnnotationMethodRun() 메소드에 한다.

* **요구사항 4 - private field에 값 할당**
  - [X] 자바 Reflection API를 활용해 다음 Car 클래스의 name과 price 필드에 값을 할당한 후 getter 메소드를 통해 값을 확인한다.
  - [X] 구현은 ReflectionTest 클래스의 privateFieldAccess() 메소드에 한다.

* **요구사항 5 - 인자를 가진 생성자의 인스턴스 생성**
  - [X] Car 클래스의 인스턴스를 자바 Reflection API를 활용해 Car 인스턴스를 생성한다.
  - [X] 구현은 src/test/java/persistence/study > ReflectionTest 클래스의 constructorWithArgs() 메소드에 한다.

## 2단계 - QueryBuilder DDL

* 요구사항 1 - 아래 정보를 바탕으로 create 쿼리 만들어보기
``` java
@Entity
public class Person {
    
    @Id
    private Long id;
    
    private String name;
    
    private Integer age;
    
}
```
* 결과
```sql
CREATE TABLE Person
(
    id   bigInt ,
    name varchar(255),
    age  integer,
    primary key (id)
)

```
- [X] PK를 가진 create 쿼리 만들어보기
  - [X] @Entity 어노테이션이 안 붙어있으면 예외가 발생한다.
  - [X] Java와 JDBC간의 타입을 치환해준다
  - [X] @Id 어노테이션이 있으면 pirmary key 키워드를 추가한다.

* 요구사항 2 - 칼럼이름이 변경되는 create 쿼리 만들어보기
```java
@Entity
public class Person {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nick_name")
    private String name;

    @Column(name = "old")
    private Integer age;
    
    @Column(nullable = false)
    private String email;

}
```
* 결과
```sql
CREATE TABLE Person
(
    id      bigInt generated by default as identity,
    nick_name varchar(255),
    old     integer,
    email   varchar(255) not null, 
    primary key (id)
)
```
- [X] 칼럼이름이 변경되는 create 쿼리 만들어보기
  - [X] 기본값 전략을 @GeneratedValue 으로 변경한다.
  - [X] @Column 어노테이션이 있으면 칼럼 이름을 변경한다.
  - [X] @Column(nullable = false) 어노테이션이 있으면 not null 키워드를 추가한다.
     
* 요구사항 3 - @Transient와 @Table 이름이 변경되는 create 쿼리 만들어보기
```java 
@Table(name = "users")
@Entity
public class Person {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nick_name")
    private String name;

    @Column(name = "old")
    private Integer age;

    @Column(nullable = false)
    private String email;

    @Transient
    private Integer index;

}
```
* 결과
```sql
CREATE TABLE users
(
    id    bigInt generated by default as identity,
    nick_name varchar(255),
    old     integer,
    email   varchar(255) not null,
    primary key (id)
)
```
- [X] @Transient와 @Table 이름이 변경되는 create 쿼리 만들어보기
  - [X] @Transient 어노테이션이 있으면 해당 필드를 제외한다.
  - [X] @Table 어노테이션에 이름이 있으면 테이블 이름을 변경한다.

* 요구 사항 4 정보를 바탕으로 drop 쿼리 만들어보기
* 결과
```sql  
    DROP TABLE users
```
- [X] 정보를 바탕으로 drop 쿼리 만들어보기
  - [X] @Entity 어노테이션이 안 붙어있으면 예외가 발생한다.
  - [X] @Table 어노테이션에 이름이 있으면 테이블 이름을 변경한다.

---

## 3단계 - QueryBuilder DML

* Person 객체 
```java 
@Table(name = "users")
@Entity
public class Person {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nick_name")
    private String name;

    @Column(name = "old")
    private Integer age;

    @Column(nullable = false)
    private String email;

    @Transient
    private Integer index;

}
```

요구사항 1 - insert 구현해보기
  - [X] 구현은 src/main/java/persistence > sql/dml > 하위에 구현한다
        위의 정보를 통해 Person 클래스의 정보를 업데이트 해준다
        @Entity, @Table, @Id, @Column, @Transient 를 고려해서 잘 작성해보자
  - [X] @Transient 어노테이션이 있으면 인설트 쿼리에 제외 된다.
  - [X] @Id 전략이 generate면 쿼리에 제외 된다.
  - [X] insert into table (column1, column2, column3) values (value1, value2, value3) 형식으로 구현한다.

요구사항 2 - 위의 정보를 바탕으로 모두 조회(findAll) 기능 구현해보기
- [X] 저장된 엔티티 데이터가 조회 된다 
- [X] 쿼리 실행을 통해 데이터를 여러 row 를 넣어 정상적으로 나오는지 확인해보자
  - [X] 통합테스트 작성 하여 검증하기.

요구사항 3 - 위의 정보를 바탕으로 단건 조회(findById) 기능 구현해보기
- [X] id를 기준으로 엔티티를 조회한다.
- [X] 실제 테이블 id 으로 엔티티를 조회한다.
  - [X] 통합테스트 작성 하여 검증하기.

요구사항 4 - 위의 정보를 바탕으로 delete 쿼리 만들어보기
- [x] id를 기준으로 엔티티를 삭제한다.
  - [x] 통합테스트 작성 하여 검증하기.
 
